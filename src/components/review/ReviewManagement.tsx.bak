import { useState, useEffect, useMemo } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Grid,
  Pagination,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  TextField,
  InputAdornment,
  Chip,
  ToggleButton,
  ToggleButtonGroup,
  Rating,
  Paper,
  Collapse,
  IconButton,
} from '@mui/material';
import {
  Search as SearchIcon,
  FilterList as FilterListIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
} from '@mui/icons-material';
// DatePicker imports temporarily commented out due to ES module import issues
// import { DatePicker, LocalizationProvider } from '@mui/x-date-pickers';
// import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ja } from 'date-fns/locale';
import { Review } from '@/types';
import axios from 'axios';

type SortOption = 'date-desc' | 'date-asc' | 'rating-desc' | 'rating-asc';
type DateRangePreset = 'all' | 'last7days' | 'last30days' | 'custom';
type ReplyStatusFilter = 'all' | 'replied' | 'unreplied';

export const ReviewManagement = () => {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [page, setPage] = useState(1);
  const [total, setTotal] = useState(0);
  const [limit] = useState(10);
  const [status, setStatus] = useState<string>('');
  const [locationId, setLocationId] = useState<string>('');

  // Search and filter states
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedRatings, setSelectedRatings] = useState<number[]>([]);
  const [dateRangePreset, setDateRangePreset] = useState<DateRangePreset>('all');
  const [customStartDate, setCustomStartDate] = useState<Date | null>(null);
  const [customEndDate, setCustomEndDate] = useState<Date | null>(null);
  const [replyStatusFilter, setReplyStatusFilter] = useState<ReplyStatusFilter>('all');
  const [sortOption, setSortOption] = useState<SortOption>('date-desc');
  const [showFilters, setShowFilters] = useState(true);

  const fetchReviews = async () => {
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString(),
      });
      if (status) params.append('status', status);
      if (locationId) params.append('location_id', locationId);

      const response = await axios.get<{ data: Review[]; pagination: { total: number } }>(
        `/api/reviews?${params.toString()}`
      );
      setReviews(response.data.data);
      setTotal(response.data.pagination.total);
    } catch (error) {
      console.error('レビューの取得に失敗しました:', error);
    }
  };

  useEffect(() => {
    fetchReviews();
  }, [page, status, locationId]);

  const handleStatusChange = async (reviewId: string, newStatus: string) => {
    try {
      await axios.put(`/api/reviews/${reviewId}`, { status: newStatus });
      fetchReviews();
    } catch (error) {
      console.error('レビューの更新に失敗しました:', error);
    }
  };

  // Toggle rating filter
  const handleRatingToggle = (rating: number) => {
    setSelectedRatings((prev) =>
      prev.includes(rating)
        ? prev.filter((r) => r !== rating)
        : [...prev, rating]
    );
    setPage(1); // Reset to first page when filtering
  };

  // Handle date range preset change
  const handleDateRangePresetChange = (preset: DateRangePreset) => {
    setDateRangePreset(preset);
    if (preset !== 'custom') {
      setCustomStartDate(null);
      setCustomEndDate(null);
    }
    setPage(1);
  };

  // Calculate date range based on preset
  const getDateRange = (): { start: Date | null; end: Date | null } => {
    const now = new Date();
    switch (dateRangePreset) {
      case 'last7days':
        return {
          start: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
          end: now,
        };
      case 'last30days':
        return {
          start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000),
          end: now,
        };
      case 'custom':
        return { start: customStartDate, end: customEndDate };
      default:
        return { start: null, end: null };
    }
  };

  // Filter and sort reviews
  const filteredAndSortedReviews = useMemo(() => {
    let filtered = [...reviews];

    // Search filter (author name and comment)
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (review) =>
          review.author.toLowerCase().includes(query) ||
          review.comment.toLowerCase().includes(query)
      );
    }

    // Rating filter
    if (selectedRatings.length > 0) {
      filtered = filtered.filter((review) =>
        selectedRatings.includes(review.rating)
      );
    }

    // Date range filter
    const { start, end } = getDateRange();
    if (start || end) {
      filtered = filtered.filter((review) => {
        const reviewDate = new Date(review.created_at || '');
        if (start && reviewDate < start) return false;
        if (end && reviewDate > end) return false;
        return true;
      });
    }

    // Reply status filter
    if (replyStatusFilter !== 'all') {
      filtered = filtered.filter((review) => {
        const hasReply = review.status === 'responded';
        return replyStatusFilter === 'replied' ? hasReply : !hasReply;
      });
    }

    // Sort
    filtered.sort((a, b) => {
      switch (sortOption) {
        case 'date-desc':
          return new Date(b.created_at || '').getTime() - new Date(a.created_at || '').getTime();
        case 'date-asc':
          return new Date(a.created_at || '').getTime() - new Date(b.created_at || '').getTime();
        case 'rating-desc':
          return b.rating - a.rating;
        case 'rating-asc':
          return a.rating - b.rating;
        default:
          return 0;
      }
    });

    return filtered;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [reviews, searchQuery, selectedRatings, dateRangePreset, customStartDate, customEndDate, replyStatusFilter, sortOption]);

  // Clear all filters
  const handleClearFilters = () => {
    setSearchQuery('');
    setSelectedRatings([]);
    setDateRangePreset('all');
    setCustomStartDate(null);
    setCustomEndDate(null);
    setReplyStatusFilter('all');
    setSortOption('date-desc');
    setPage(1);
  };

  // Count active filters
  const activeFilterCount = useMemo(() => {
    let count = 0;
    if (searchQuery.trim()) count++;
    if (selectedRatings.length > 0) count++;
    if (dateRangePreset !== 'all') count++;
    if (replyStatusFilter !== 'all') count++;
    if (sortOption !== 'date-desc') count++;
    return count;
  }, [searchQuery, selectedRatings, dateRangePreset, replyStatusFilter, sortOption]);

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ja}>
      <Box sx={{ p: 3 }}>
        <Typography variant="h4" sx={{ mb: 3 }}>
          レビュー管理
        </Typography>

        {/* Search Bar */}
        <Box sx={{ mb: 2 }}>
          <TextField
            fullWidth
            placeholder="レビュアー名やコメント内容で検索..."
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setPage(1);
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
        </Box>

        {/* Filter Toggle Button */}
        <Box sx={{ mb: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
          <Button
            variant="outlined"
            startIcon={<FilterListIcon />}
            endIcon={showFilters ? <ExpandLessIcon /> : <ExpandMoreIcon />}
            onClick={() => setShowFilters(!showFilters)}
          >
            フィルター {activeFilterCount > 0 && `(${activeFilterCount})`}
          </Button>
          {activeFilterCount > 0 && (
            <Button
              variant="text"
              size="small"
              onClick={handleClearFilters}
            >
              フィルターをクリア
            </Button>
          )}
        </Box>

        {/* Filters Panel */}
        <Collapse in={showFilters}>
          <Paper sx={{ p: 3, mb: 3 }}>
            <Grid container spacing={3}>
              {/* Rating Filter */}
              <Grid item xs={12}>
                <Typography variant="subtitle2" gutterBottom>
                  評価
                </Typography>
                <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                  {[5, 4, 3, 2, 1].map((rating) => (
                    <Chip
                      key={rating}
                      label={
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                          <Rating value={rating} readOnly size="small" />
                        </Box>
                      }
                      onClick={() => handleRatingToggle(rating)}
                      color={selectedRatings.includes(rating) ? 'primary' : 'default'}
                      variant={selectedRatings.includes(rating) ? 'filled' : 'outlined'}
                    />
                  ))}
                </Box>
              </Grid>

              {/* Date Range Filter */}
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" gutterBottom>
                  期間
                </Typography>
                <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
                  <Chip
                    label="すべて"
                    onClick={() => handleDateRangePresetChange('all')}
                    color={dateRangePreset === 'all' ? 'primary' : 'default'}
                    variant={dateRangePreset === 'all' ? 'filled' : 'outlined'}
                  />
                  <Chip
                    label="過去7日間"
                    onClick={() => handleDateRangePresetChange('last7days')}
                    color={dateRangePreset === 'last7days' ? 'primary' : 'default'}
                    variant={dateRangePreset === 'last7days' ? 'filled' : 'outlined'}
                  />
                  <Chip
                    label="過去30日間"
                    onClick={() => handleDateRangePresetChange('last30days')}
                    color={dateRangePreset === 'last30days' ? 'primary' : 'default'}
                    variant={dateRangePreset === 'last30days' ? 'filled' : 'outlined'}
                  />
                  <Chip
                    label="カスタム期間"
                    onClick={() => handleDateRangePresetChange('custom')}
                    color={dateRangePreset === 'custom' ? 'primary' : 'default'}
                    variant={dateRangePreset === 'custom' ? 'filled' : 'outlined'}
                  />
                </Box>

                {dateRangePreset === 'custom' && (
                  <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                    <DatePicker
                      label="開始日"
                      value={customStartDate}
                      onChange={(date) => {
                        setCustomStartDate(date);
                        setPage(1);
                      }}
                      slotProps={{ textField: { size: 'small' } }}
                    />
                    <DatePicker
                      label="終了日"
                      value={customEndDate}
                      onChange={(date) => {
                        setCustomEndDate(date);
                        setPage(1);
                      }}
                      slotProps={{ textField: { size: 'small' } }}
                    />
                  </Box>
                )}
              </Grid>

              {/* Reply Status Filter */}
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" gutterBottom>
                  返信ステータス
                </Typography>
                <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                  <Chip
                    label="すべて"
                    onClick={() => {
                      setReplyStatusFilter('all');
                      setPage(1);
                    }}
                    color={replyStatusFilter === 'all' ? 'primary' : 'default'}
                    variant={replyStatusFilter === 'all' ? 'filled' : 'outlined'}
                  />
                  <Chip
                    label="未返信"
                    onClick={() => {
                      setReplyStatusFilter('unreplied');
                      setPage(1);
                    }}
                    color={replyStatusFilter === 'unreplied' ? 'primary' : 'default'}
                    variant={replyStatusFilter === 'unreplied' ? 'filled' : 'outlined'}
                  />
                  <Chip
                    label="返信済み"
                    onClick={() => {
                      setReplyStatusFilter('replied');
                      setPage(1);
                    }}
                    color={replyStatusFilter === 'replied' ? 'primary' : 'default'}
                    variant={replyStatusFilter === 'replied' ? 'filled' : 'outlined'}
                  />
                </Box>
              </Grid>

              {/* Sort Options */}
              <Grid item xs={12}>
                <Typography variant="subtitle2" gutterBottom>
                  並び替え
                </Typography>
                <FormControl size="small" sx={{ minWidth: 200 }}>
                  <Select
                    value={sortOption}
                    onChange={(e) => {
                      setSortOption(e.target.value as SortOption);
                      setPage(1);
                    }}
                  >
                    <MenuItem value="date-desc">日付: 新しい順</MenuItem>
                    <MenuItem value="date-asc">日付: 古い順</MenuItem>
                    <MenuItem value="rating-desc">評価: 高い順</MenuItem>
                    <MenuItem value="rating-asc">評価: 低い順</MenuItem>
                  </Select>
                </FormControl>
              </Grid>

              {/* Legacy Status Filter */}
              <Grid item xs={12}>
                <FormControl size="small" sx={{ minWidth: 200 }}>
                  <InputLabel>ステータス</InputLabel>
                  <Select
                    value={status}
                    label="ステータス"
                    onChange={(e) => setStatus(e.target.value)}
                  >
                    <MenuItem value="">すべて</MenuItem>
                    <MenuItem value="pending">未対応</MenuItem>
                    <MenuItem value="responded">対応済み</MenuItem>
                    <MenuItem value="ignored">無視</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </Paper>
        </Collapse>

        {/* Results Count */}
        <Box sx={{ mb: 2 }}>
          <Typography variant="body2" color="textSecondary">
            {filteredAndSortedReviews.length} 件のレビュー
            {activeFilterCount > 0 && ` (フィルター適用中)`}
          </Typography>
        </Box>

        {/* Reviews List */}
        <Grid container spacing={3}>
          {filteredAndSortedReviews.length === 0 ? (
            <Grid item xs={12}>
              <Paper sx={{ p: 4, textAlign: 'center' }}>
                <Typography variant="body1" color="textSecondary">
                  {searchQuery || activeFilterCount > 0
                    ? '条件に一致するレビューが見つかりませんでした'
                    : 'レビューがありません'}
                </Typography>
              </Paper>
            </Grid>
          ) : (
            filteredAndSortedReviews.map((review) => (
              <Grid item xs={12} key={review.id}>
                <Card>
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                      <Typography variant="h6">{review.author}</Typography>
                      <Box sx={{ display: 'flex', gap: 1 }}>
                        {review.status === 'responded' && (
                          <Chip label="返信済み" size="small" color="success" />
                        )}
                        {review.status === 'pending' && (
                          <Chip label="未返信" size="small" color="warning" />
                        )}
                      </Box>
                    </Box>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                      <Rating value={review.rating} readOnly size="small" />
                      <Typography variant="caption" color="textSecondary">
                        {review.created_at && new Date(review.created_at).toLocaleDateString('ja-JP')}
                      </Typography>
                    </Box>
                    <Typography sx={{ mt: 1 }}>{review.comment}</Typography>
                    <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
                      <Button
                        variant="outlined"
                        size="small"
                        onClick={() => handleStatusChange(review.id, 'responded')}
                      >
                        対応済み
                      </Button>
                      <Button
                        variant="outlined"
                        size="small"
                        onClick={() => handleStatusChange(review.id, 'ignored')}
                      >
                        無視
                      </Button>
                    </Box>
                  </CardContent>
                </Card>
              </Grid>
            ))
          )}
        </Grid>

        {/* Pagination */}
        {filteredAndSortedReviews.length > 0 && (
          <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
            <Pagination
              count={Math.ceil(total / limit)}
              page={page}
              onChange={(_, value) => setPage(value)}
            />
          </Box>
        )}
      </Box>
    </LocalizationProvider>
  );
}; 